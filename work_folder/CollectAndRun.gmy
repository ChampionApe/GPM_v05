$ONEOLCOM
$EOLCOM #


# Root File for model
OPTION SYSOUT=OFF, SOLPRINT=OFF, LIMROW=0, LIMCOL=0, DECIMALS=6;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_CollectFile.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_functions.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Define function: load_level
# ----------------------------------------------------------------------------------------------------



# ----------------------------------------------------------------------------------------------------
#  Define function: load_fixed
# ----------------------------------------------------------------------------------------------------


;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_sets.gms
# ----------------------------------------------------------------------------------------------------

sets
	alias_set
	alias_map2
	n
;

alias(n,nn,nnn);

sets
	alias_[alias_set,alias_map2]
	map_all[n,nn]
	inp[n]
	out[n]
	int[n]
	fg[n]
	wT[n]
	kno_out[n]
	kno_inp[n]
	map_T_inp[n,nn]
	kno_T_inp[n]
	bra_T_inp[n]
	inp_T_inp[n]
	out_T_inp[n]
	kno_no_T_inp[n]
	bra_o_T_inp[n]
	bra_no_T_inp[n]
	map_T_out[n,nn]
	kno_T_out[n]
	bra_T_out[n]
	inp_T_out[n]
	out_T_out[n]
	bra_o_T_out[n]
	bra_no_T_out[n]
	map_C[n,nn]
	kno_C[n]
	bra_C[n]
	inp_C[n]
	out_C[n]
	kno_no_C[n]
	bra_o_C[n]
	bra_no_C[n]
	map_E[n,nn]
	kno_E[n]
	bra_E[n]
	inp_E[n]
	out_E[n]
	kno_no_E[n]
	bra_o_E[n]
	bra_no_E[n]
	n_out[n]
	endo_PbT[n]
	exo_mu[n,nn]
;
$GDXIN %A1_0%
$onMulti
$load alias_set
$load alias_map2
$load n
$load inp
$load out
$load int
$load fg
$load wT
$load kno_out
$load kno_inp
$load kno_T_inp
$load bra_T_inp
$load inp_T_inp
$load out_T_inp
$load kno_no_T_inp
$load bra_o_T_inp
$load bra_no_T_inp
$load kno_T_out
$load bra_T_out
$load inp_T_out
$load out_T_out
$load bra_o_T_out
$load bra_no_T_out
$load kno_C
$load bra_C
$load inp_C
$load out_C
$load kno_no_C
$load bra_o_C
$load bra_no_C
$load kno_E
$load bra_E
$load inp_E
$load out_E
$load kno_no_E
$load bra_o_E
$load bra_no_E
$load n_out
$load endo_PbT
$load alias_
$load map_all
$load map_T_inp
$load map_T_out
$load map_C
$load map_E
$load exo_mu
$GDXIN
$offMulti
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_parameters.gms
# ----------------------------------------------------------------------------------------------------

;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_groups.gms
# ----------------------------------------------------------------------------------------------------


# -------------------------------------------A1_g_tech_endo-------------------------------------------
#  Initialize A1_g_tech_endo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE mu[n,nn] "";
mu.L[n,nn]$((map_all[n,nn] and not exo_mu[n,nn])) = 0;
VARIABLE markup[n] "";
markup.L[n]$(out[n]) = 0;
$onlisting


# --------------------------------------------A1_g_tech_exo-------------------------------------------
#  Initialize A1_g_tech_exo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE sigma[n] "";
sigma.L[n]$(kno_inp[n]) = 0;
VARIABLE eta[n] "";
eta.L[n]$(kno_out[n]) = 0;
$onlisting


# --------------------------------------------A1_g_endovars-------------------------------------------
#  Initialize A1_g_endovars group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE PwT[n] "";
PwT.L[n]$(int[n]) = 0;
VARIABLE qD[n] "";
qD.L[n]$(int[n]) = 0;
VARIABLE PbT[n] "";
PbT.L[n]$(endo_PbT[n]) = 0;
$onlisting


# -------------------------------------------A1_g_calib_exo-------------------------------------------
#  Initialize A1_g_calib_exo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE Peq[n] "";
Peq.L[n]$(n_out[n]) = 0;
$onlisting


# ----------------------------------------------A1_g_tech---------------------------------------------
#  Initialize A1_g_tech group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting


# --------------------------------------------A1_g_exovars--------------------------------------------
#  Initialize A1_g_exovars group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE qS[n] "";
qS.L[n]$(out[n]) = 0;
VARIABLE tauS[n] "";
tauS.L[n]$(out[n]) = 0;
VARIABLE tauLump "";
tauLump.L = 0;
$onlisting
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_PwT[n] "";
    load_PwT[n]$((int[n])) = 0;
  
    parameter load_qD[n] "";
    load_qD[n]$((int[n])) = 0;
  
    parameter load_PbT[n] "";
    load_PbT[n]$((endo_PbT[n])) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_PwT=PwT.l  load_qD=qD.l  load_PbT=PbT.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    PwT.l[n]$((int[n])) = load_PwT[n];
  
    qD.l[n]$((int[n])) = load_qD[n];
  
    PbT.l[n]$((endo_PbT[n])) = load_PbT[n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_qD[n] "";
    load_qD[n]$((inp[n])) = 0;
  
    parameter load_PbT[n] "";
    load_PbT[n]$(((out[n] and not endo_PbT[n]))) = 0;
  
    parameter load_Peq[n] "";
    load_Peq[n]$((n_out[n])) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_qD=qD.l  load_PbT=PbT.l  load_Peq=Peq.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    qD.l[n]$((inp[n])) = load_qD[n];
  
    PbT.l[n]$(((out[n] and not endo_PbT[n]))) = load_PbT[n];
  
    Peq.l[n]$((n_out[n])) = load_Peq[n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[n,nn] "";
    load_mu[n,nn]$(((map_all[n,nn] and not exo_mu[n,nn]))) = 0;
  
    parameter load_markup[n] "";
    load_markup[n]$((out[n])) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l  load_markup=markup.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[n,nn]$(((map_all[n,nn] and not exo_mu[n,nn]))) = load_mu[n,nn];
  
    markup.fx[n]$((out[n])) = load_markup[n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_sigma[n] "";
    load_sigma[n]$((kno_inp[n])) = 0;
  
    parameter load_eta[n] "";
    load_eta[n]$((kno_out[n])) = 0;
  
    parameter load_mu[n,nn] "";
    load_mu[n,nn]$((exo_mu[n,nn])) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_sigma=sigma.l  load_eta=eta.l  load_mu=mu.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    sigma.fx[n]$((kno_inp[n])) = load_sigma[n];
  
    eta.fx[n]$((kno_out[n])) = load_eta[n];
  
    mu.fx[n,nn]$((exo_mu[n,nn])) = load_mu[n,nn];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[n,nn] "";
    load_mu[n,nn]$(((exo_mu[n,nn]) or ((map_all[n,nn] and not exo_mu[n,nn])))) = 0;
  
    parameter load_markup[n] "";
    load_markup[n]$((out[n])) = 0;
  
    parameter load_sigma[n] "";
    load_sigma[n]$((kno_inp[n])) = 0;
  
    parameter load_eta[n] "";
    load_eta[n]$((kno_out[n])) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l  load_markup=markup.l  load_sigma=sigma.l  load_eta=eta.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[n,nn]$(((exo_mu[n,nn]) or ((map_all[n,nn] and not exo_mu[n,nn])))) = load_mu[n,nn];
  
    markup.fx[n]$((out[n])) = load_markup[n];
  
    sigma.fx[n]$((kno_inp[n])) = load_sigma[n];
  
    eta.fx[n]$((kno_out[n])) = load_eta[n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_PwT[n] "";
    load_PwT[n]$((inp[n])) = 0;
  
    parameter load_qS[n] "";
    load_qS[n]$((out[n])) = 0;
  
    parameter load_tauS[n] "";
    load_tauS[n]$((out[n])) = 0;
  
    parameter load_tauLump "";
    load_tauLump$((1)) = 0;
  
  execute_load "%A1_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_PwT=PwT.l  load_qS=qS.l  load_tauS=tauS.l  load_tauLump=tauLump.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    PwT.fx[n]$((inp[n])) = load_PwT[n];
  
    qS.fx[n]$((out[n])) = load_qS[n];
  
    tauS.fx[n]$((out[n])) = load_tauS[n];
  
    tauLump.fx$((1)) = load_tauLump;
$onlisting
;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\A1_blocks.gms
# ----------------------------------------------------------------------------------------------------


# -----------------------------------------------M_T_inp----------------------------------------------
#  Initialize M_T_inp equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_out_T_inp[n];
E_zp_out_T_inp[n]$(out_t_inp[n]).. 	PbT[n]*qS[n]  =E=  sum(nn$(map_T_inp[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_zp_nout_T_inp[n];
E_zp_nout_T_inp[n]$(kno_no_t_inp[n]).. 	PwT[n]*qD[n]  =E=  sum(nn$(map_T_inp[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_q_out_T_inp[n];
E_q_out_T_inp[n]$(bra_o_t_inp[n]).. 	qD[n]  =E=  sum(nn$(map_T_inp[n,nn]), mu[n,nn] * (PbT[nn]/PwT[n])**(sigma[nn]) * qS[nn]);
EQUATION E_q_nout_T_inp[n];
E_q_nout_T_inp[n]$(bra_no_t_inp[n]).. 	qD[n]  =E=  sum(nn$(map_T_inp[n,nn]), mu[n,nn] * (PwT[nn]/PwT[n])**(sigma[nn]) * qD[nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_T_inp model
# ----------------------------------------------------------------------------------------------------
Model M_T_inp /
E_zp_out_T_inp, E_zp_nout_T_inp, E_q_out_T_inp, E_q_nout_T_inp
/;


# -----------------------------------------------M_T_out----------------------------------------------
#  Initialize M_T_out equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_T_out[n];
E_zp_T_out[n]$(kno_t_out[n]).. 	PwT[n]*qD[n]  =E=  sum(nn$(map_T_out[nn,n] and out[nn]), qS[nn]*PbT[nn])+sum(nn$(map_T_out[nn,n] and not out[nn]), qD[nn]*PwT[nn]);
EQUATION E_q_out_T_out[n];
E_q_out_T_out[n]$(bra_o_t_out[n]).. 	qS[n]  =E=  sum(nn$(map_T_out[n,nn]), mu[n,nn] * (PbT[n]/PwT[nn])**(-eta[nn]) * qD[nn]/(sum(nnn$(map_T_out[nnn,nn] and out[nnn]), mu[nnn,nn]*(PbT[nnn]/PwT[nn])**(-eta[nn]))+sum(nnn$(map_T_out[nnn,nn] and not out[nnn]), mu[nnn,nn]*(PwT[nnn]/PwT[nn])**(-eta[nn]))));
EQUATION E_q_nout_T_out[n];
E_q_nout_T_out[n]$(bra_no_t_out[n]).. 	qD[n]  =E=  sum(nn$(map_T_out[n,nn]), mu[n,nn] * (PwT[n]/PwT[nn])**(-eta[nn]) * qD[nn]/(sum(nnn$(map_T_out[nnn,nn] and out[nnn]), mu[nnn,nn]*(PbT[nnn]/PwT[nn])**(-eta[nn]))+sum(nnn$(map_T_out[nnn,nn] and not out[nnn]), mu[nnn,nn]*(PwT[nnn]/PwT[nn])**(-eta[nn]))));

# ----------------------------------------------------------------------------------------------------
#  Define M_T_out model
# ----------------------------------------------------------------------------------------------------
Model M_T_out /
E_zp_T_out, E_q_out_T_out, E_q_nout_T_out
/;


# -------------------------------------------------M_C------------------------------------------------
#  Initialize M_C equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_out_C[n];
E_zp_out_C[n]$(out_c[n]).. 	PbT[n]*qS[n]  =E=  sum(nn$(map_C[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_zp_nout_C[n];
E_zp_nout_C[n]$(kno_no_c[n]).. 	PwT[n]*qD[n]  =E=  sum(nn$(map_C[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_q_out_C[n];
E_q_out_C[n]$(bra_o_c[n]).. 	qD[n]  =E=  sum(nn$(map_C[n,nn]), mu[n,nn] * exp((PbT[nn]-PwT[n])*sigma[nn]) * qS[nn]/ sum(nnn$(map_C[nnn,nn]), mu[nnn,nn]*exp((PbT[nn]-PwT[nnn])*sigma[nn])));
EQUATION E_q_nout_C[n];
E_q_nout_C[n]$(bra_no_c[n]).. 	qD[n]  =E=  sum(nn$(map_C[n,nn]), mu[n,nn] * exp((PwT[nn]-PwT[n])*sigma[nn]) * qD[nn]/ sum(nnn$(map_C[nnn,nn]), mu[nnn,nn]*exp((PwT[nn]-PwT[nnn])*sigma[nn])));

# ----------------------------------------------------------------------------------------------------
#  Define M_C model
# ----------------------------------------------------------------------------------------------------
Model M_C /
E_zp_out_C, E_zp_nout_C, E_q_out_C, E_q_nout_C
/;


# -------------------------------------------------M_E------------------------------------------------
#  Initialize M_E equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_out_E[n];
E_zp_out_E[n]$(out_e[n]).. 	PbT[n]*qS[n]  =E=  sum(nn$(map_E[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_zp_nout_E[n];
E_zp_nout_E[n]$(kno_no_e[n]).. 	PwT[n]*qD[n]  =E=  sum(nn$(map_E[nn,n]), qD[nn]*PwT[nn]);
EQUATION E_q_out_E[n];
E_q_out_E[n]$(bra_o_e[n]).. 	qD[n]  =E=  sum(nn$(map_E[n,nn]), mu[n,nn] * (PbT[nn]/PwT[n])**(sigma[nn]) * qS[nn] / sum(nnn$(map_E[nnn,nn]), mu[nnn,nn] * (PbT[nn]/PwT[nnn])**(sigma[nn])));
EQUATION E_q_nout_E[n];
E_q_nout_E[n]$(bra_no_e[n]).. 	qD[n]  =E=  sum(nn$(map_E[n,nn]), mu[n,nn] * (PwT[nn]/PwT[n])**(sigma[nn]) * qD[nn] / sum(nnn$(map_E[nnn,nn]), mu[nnn,nn] * (PwT[nn]/PwT[nnn])**(sigma[nn])));

# ----------------------------------------------------------------------------------------------------
#  Define M_E model
# ----------------------------------------------------------------------------------------------------
Model M_E /
E_zp_out_E, E_zp_nout_E, E_q_out_E, E_q_nout_E
/;


# -----------------------------------------------M_A1_pw----------------------------------------------
#  Initialize M_A1_pw equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_pw_A1[n];
E_pw_A1[n]$(out[n]).. 	Peq[n]  =E=  (1+markup[n])*(PbT[n]*(1+tauLump/sum(nn$(out[nn]), qS[nn]*PbT[nn]))+tauS[n]+0);

# ----------------------------------------------------------------------------------------------------
#  Define M_A1_pw model
# ----------------------------------------------------------------------------------------------------
Model M_A1_pw /
E_pw_A1
/;

;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\RunFile.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------$FIX A1_g_tech, A1_g_exovars;
# ----------------------------------------------------------------------------------------------------
$offlisting
mu.FX[n,nn]$((exo_mu[n,nn]) or ((map_all[n,nn] and not exo_mu[n,nn]))) = mu.L[n,nn];
markup.FX[n]$(out[n]) = markup.L[n];
sigma.FX[n]$(kno_inp[n]) = sigma.L[n];
eta.FX[n]$(kno_out[n]) = eta.L[n];
PwT.FX[n]$(inp[n]) = PwT.L[n];
qS.FX[n]$(out[n]) = qS.L[n];
tauS.FX[n]$(out[n]) = tauS.L[n];
tauLump.FX = tauLump.L;
$onlisting

# ----------------------------------------------------------------------------------------------------$UNFIX A1_g_endovars, A1_g_calib_exo;
# ----------------------------------------------------------------------------------------------------
$offlisting
PwT.lo[n]$(int[n]) = -inf;
PwT.up[n]$(int[n]) = inf;
qD.lo[n]$((inp[n]) or (int[n])) = -inf;
qD.up[n]$((inp[n]) or (int[n])) = inf;
PbT.lo[n]$(((out[n] and not endo_PbT[n])) or (endo_PbT[n])) = -inf;
PbT.up[n]$(((out[n] and not endo_PbT[n])) or (endo_PbT[n])) = inf;
Peq.lo[n]$(n_out[n]) = -inf;
Peq.up[n]$(n_out[n]) = inf;
$onlisting

# ----------------------------------------------------------------------------------------------------
#  Define A1_B model
# ----------------------------------------------------------------------------------------------------
Model A1_B /
E_zp_out_E, E_zp_nout_E, E_q_out_E, E_q_nout_E, E_zp_out_T_inp, E_zp_nout_T_inp, E_q_out_T_inp, E_q_nout_T_inp, E_zp_T_out, E_q_out_T_out, E_q_nout_T_out, E_pw_A1, E_zp_out_C, E_zp_nout_C, E_q_out_C, E_q_nout_C
/;

scalars A1_B_modelstat, A1_B_solvestat;
solve A1_B using CNS;
A1_B_modelstat = A1_B.modelstat; A1_B_solvestat = A1_B.solvestat;
;
