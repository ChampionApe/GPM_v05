$ONEOLCOM
$EOLCOM #


# Root File for model
OPTION SYSOUT=OFF, SOLPRINT=OFF, LIMROW=0, LIMCOL=0, DECIMALS=6;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_CollectFile.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_functions.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Define function: load_level
# ----------------------------------------------------------------------------------------------------



# ----------------------------------------------------------------------------------------------------
#  Define function: load_fixed
# ----------------------------------------------------------------------------------------------------


;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_sets.gms
# ----------------------------------------------------------------------------------------------------

sets
	alias_set
	alias_map2
	n
	s
;

alias(n,nn,nnn);

sets
	alias_[alias_set,alias_map2]
	map_all[s,n,nn]
	inp[s,n]
	out[s,n]
	int[s,n]
	fg[n]
	wT[s,n]
	kno_out[s,n]
	kno_inp[s,n]
	map_lower_nests[s,n,nn]
	kno_lower_nests[s,n]
	bra_lower_nests[s,n]
	inp_lower_nests[s,n]
	out_lower_nests[s,n]
	kno_no_lower_nests[s,n]
	bra_o_lower_nests[s,n]
	bra_no_lower_nests[s,n]
	map_upper_nest[s,n,nn]
	kno_upper_nest[s,n]
	bra_upper_nest[s,n]
	inp_upper_nest[s,n]
	out_upper_nest[s,n]
	kno_no_upper_nest[s,n]
	bra_o_upper_nest[s,n]
	bra_no_upper_nest[s,n]
	n_out[n]
	s_prod[s]
	endo_PbT[s,n]
	exo_mu[s,n,nn]
;
$GDXIN %p_0%
$onMulti
$load alias_set
$load alias_map2
$load n
$load s
$load fg
$load n_out
$load s_prod
$load alias_
$load map_all
$load inp
$load out
$load int
$load wT
$load kno_out
$load kno_inp
$load map_lower_nests
$load kno_lower_nests
$load bra_lower_nests
$load inp_lower_nests
$load out_lower_nests
$load kno_no_lower_nests
$load bra_o_lower_nests
$load bra_no_lower_nests
$load map_upper_nest
$load kno_upper_nest
$load bra_upper_nest
$load inp_upper_nest
$load out_upper_nest
$load kno_no_upper_nest
$load bra_o_upper_nest
$load bra_no_upper_nest
$load endo_PbT
$load exo_mu
$GDXIN
$offMulti
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_parameters.gms
# ----------------------------------------------------------------------------------------------------

;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_groups.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------p_static_g_tech_endo----------------------------------------
#  Initialize p_static_g_tech_endo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE mu[s,n,nn] "";
mu.L[s,n,nn]$((map_all[s,n,nn] and not exo_mu[s,n,nn])) = 0;
VARIABLE markup[s,n] "";
markup.L[s,n]$(out[s,n]) = 0;
$onlisting


# -----------------------------------------p_static_g_tech_exo----------------------------------------
#  Initialize p_static_g_tech_exo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE sigma[s,n] "";
sigma.L[s,n]$(kno_inp[s,n]) = 0;
VARIABLE eta[s,n] "";
eta.L[s,n]$(kno_out[s,n]) = 0;
$onlisting


# -----------------------------------------p_static_g_endovars----------------------------------------
#  Initialize p_static_g_endovars group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE PwT[s,n] "";
PwT.L[s,n]$(int[s,n]) = 0;
VARIABLE qD[s,n] "";
qD.L[s,n]$(int[s,n]) = 0;
VARIABLE PbT[s,n] "";
PbT.L[s,n]$(endo_PbT[s,n]) = 0;
$onlisting


# ----------------------------------------p_static_g_calib_exo----------------------------------------
#  Initialize p_static_g_calib_exo group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE Peq[n] "";
Peq.L[n]$(n_out[n]) = 0;
$onlisting


# -------------------------------------------p_static_g_tech------------------------------------------
#  Initialize p_static_g_tech group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting


# -----------------------------------------p_static_g_exovars-----------------------------------------
#  Initialize p_static_g_exovars group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE qS[s,n] "";
qS.L[s,n]$(out[s,n]) = 0;
VARIABLE tauS[s,n] "";
tauS.L[s,n]$(out[s,n]) = 0;
VARIABLE tauLump[s] "";
tauLump.L[s]$(s_prod[s]) = 0;
$onlisting
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_PwT[s,n] "";
    load_PwT[s,n]$((int[s,n])) = 0;
  
    parameter load_qD[s,n] "";
    load_qD[s,n]$((int[s,n])) = 0;
  
    parameter load_PbT[s,n] "";
    load_PbT[s,n]$((endo_PbT[s,n])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_PwT=PwT.l  load_qD=qD.l  load_PbT=PbT.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    PwT.l[s,n]$((int[s,n])) = load_PwT[s,n];
  
    qD.l[s,n]$((int[s,n])) = load_qD[s,n];
  
    PbT.l[s,n]$((endo_PbT[s,n])) = load_PbT[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_qD[s,n] "";
    load_qD[s,n]$((inp[s,n])) = 0;
  
    parameter load_PbT[s,n] "";
    load_PbT[s,n]$(((out[s,n] and not endo_PbT[s,n]))) = 0;
  
    parameter load_Peq[n] "";
    load_Peq[n]$((n_out[n])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_qD=qD.l  load_PbT=PbT.l  load_Peq=Peq.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    qD.l[s,n]$((inp[s,n])) = load_qD[s,n];
  
    PbT.l[s,n]$(((out[s,n] and not endo_PbT[s,n]))) = load_PbT[s,n];
  
    Peq.l[n]$((n_out[n])) = load_Peq[n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$(((map_all[s,n,nn] and not exo_mu[s,n,nn]))) = 0;
  
    parameter load_markup[s,n] "";
    load_markup[s,n]$((out[s,n])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l  load_markup=markup.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[s,n,nn]$(((map_all[s,n,nn] and not exo_mu[s,n,nn]))) = load_mu[s,n,nn];
  
    markup.fx[s,n]$((out[s,n])) = load_markup[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_sigma[s,n] "";
    load_sigma[s,n]$((kno_inp[s,n])) = 0;
  
    parameter load_eta[s,n] "";
    load_eta[s,n]$((kno_out[s,n])) = 0;
  
    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$((exo_mu[s,n,nn])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_sigma=sigma.l  load_eta=eta.l  load_mu=mu.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    sigma.fx[s,n]$((kno_inp[s,n])) = load_sigma[s,n];
  
    eta.fx[s,n]$((kno_out[s,n])) = load_eta[s,n];
  
    mu.fx[s,n,nn]$((exo_mu[s,n,nn])) = load_mu[s,n,nn];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$(((exo_mu[s,n,nn]) or ((map_all[s,n,nn] and not exo_mu[s,n,nn])))) = 0;
  
    parameter load_markup[s,n] "";
    load_markup[s,n]$((out[s,n])) = 0;
  
    parameter load_sigma[s,n] "";
    load_sigma[s,n]$((kno_inp[s,n])) = 0;
  
    parameter load_eta[s,n] "";
    load_eta[s,n]$((kno_out[s,n])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l  load_markup=markup.l  load_sigma=sigma.l  load_eta=eta.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[s,n,nn]$(((exo_mu[s,n,nn]) or ((map_all[s,n,nn] and not exo_mu[s,n,nn])))) = load_mu[s,n,nn];
  
    markup.fx[s,n]$((out[s,n])) = load_markup[s,n];
  
    sigma.fx[s,n]$((kno_inp[s,n])) = load_sigma[s,n];
  
    eta.fx[s,n]$((kno_out[s,n])) = load_eta[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_PwT[s,n] "";
    load_PwT[s,n]$((inp[s,n])) = 0;
  
    parameter load_qS[s,n] "";
    load_qS[s,n]$((out[s,n])) = 0;
  
    parameter load_tauS[s,n] "";
    load_tauS[s,n]$((out[s,n])) = 0;
  
    parameter load_tauLump[s] "";
    load_tauLump[s]$((s_prod[s])) = 0;
  
  execute_load "%p_0%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_PwT=PwT.l  load_qS=qS.l  load_tauS=tauS.l  load_tauLump=tauLump.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    PwT.fx[s,n]$((inp[s,n])) = load_PwT[s,n];
  
    qS.fx[s,n]$((out[s,n])) = load_qS[s,n];
  
    tauS.fx[s,n]$((out[s,n])) = load_tauS[s,n];
  
    tauLump.fx[s]$((s_prod[s])) = load_tauLump[s];
$onlisting
;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\p_static_blocks.gms
# ----------------------------------------------------------------------------------------------------


# --------------------------------------------M_lower_nests-------------------------------------------
#  Initialize M_lower_nests equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_out_lower_nests[s,n];
E_zp_out_lower_nests[s,n]$(out_lower_nests[s,n]).. 	PbT[s,n]*qS[s,n]  =E=  sum(nn$(map_lower_nests[s,nn,n]), qD[s,nn]*PwT[s,nn]);
EQUATION E_zp_nout_lower_nests[s,n];
E_zp_nout_lower_nests[s,n]$(kno_no_lower_nests[s,n]).. 	PwT[s,n]*qD[s,n]  =E=  sum(nn$(map_lower_nests[s,nn,n]), qD[s,nn]*PwT[s,nn]);
EQUATION E_q_out_lower_nests[s,n];
E_q_out_lower_nests[s,n]$(bra_o_lower_nests[s,n]).. 	qD[s,n]  =E=  sum(nn$(map_lower_nests[s,n,nn]), mu[s,n,nn] * (PbT[s,nn]/PwT[s,n])**(sigma[s,nn]) * qS[s,nn]);
EQUATION E_q_nout_lower_nests[s,n];
E_q_nout_lower_nests[s,n]$(bra_no_lower_nests[s,n]).. 	qD[s,n]  =E=  sum(nn$(map_lower_nests[s,n,nn]), mu[s,n,nn] * (PwT[s,nn]/PwT[s,n])**(sigma[s,nn]) * qD[s,nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_lower_nests model
# ----------------------------------------------------------------------------------------------------
Model M_lower_nests /
E_zp_out_lower_nests, E_zp_nout_lower_nests, E_q_out_lower_nests, E_q_nout_lower_nests
/;


# --------------------------------------------M_upper_nest--------------------------------------------
#  Initialize M_upper_nest equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_zp_out_upper_nest[s,n];
E_zp_out_upper_nest[s,n]$(out_upper_nest[s,n]).. 	PbT[s,n]*qS[s,n]  =E=  sum(nn$(map_upper_nest[s,nn,n]), qD[s,nn]*PwT[s,nn]);
EQUATION E_zp_nout_upper_nest[s,n];
E_zp_nout_upper_nest[s,n]$(kno_no_upper_nest[s,n]).. 	PwT[s,n]*qD[s,n]  =E=  sum(nn$(map_upper_nest[s,nn,n]), qD[s,nn]*PwT[s,nn]);
EQUATION E_q_out_upper_nest[s,n];
E_q_out_upper_nest[s,n]$(bra_o_upper_nest[s,n]).. 	qD[s,n]  =E=  sum(nn$(map_upper_nest[s,n,nn]), mu[s,n,nn] * (PbT[s,nn]/PwT[s,n])**(sigma[s,nn]) * qS[s,nn]);
EQUATION E_q_nout_upper_nest[s,n];
E_q_nout_upper_nest[s,n]$(bra_no_upper_nest[s,n]).. 	qD[s,n]  =E=  sum(nn$(map_upper_nest[s,n,nn]), mu[s,n,nn] * (PwT[s,nn]/PwT[s,n])**(sigma[s,nn]) * qD[s,nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_upper_nest model
# ----------------------------------------------------------------------------------------------------
Model M_upper_nest /
E_zp_out_upper_nest, E_zp_nout_upper_nest, E_q_out_upper_nest, E_q_nout_upper_nest
/;


# --------------------------------------------M_p_static_pw-------------------------------------------
#  Initialize M_p_static_pw equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_pw_p_static[s,n];
E_pw_p_static[s,n]$(out[s,n]).. 	Peq[n]  =E=  (1+markup[s,n])*(PbT[s,n]*(1+tauLump[s]/sum(nn$(out[s,nn]), qS[s,nn]*PbT[s,nn]))+tauS[s,n]+0);

# ----------------------------------------------------------------------------------------------------
#  Define M_p_static_pw model
# ----------------------------------------------------------------------------------------------------
Model M_p_static_pw /
E_pw_p_static
/;

;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\RunFile.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------$FIX p_static_g_tech, p_static_g_exovars;
# ----------------------------------------------------------------------------------------------------
$offlisting
mu.FX[s,n,nn]$((exo_mu[s,n,nn]) or ((map_all[s,n,nn] and not exo_mu[s,n,nn]))) = mu.L[s,n,nn];
markup.FX[s,n]$(out[s,n]) = markup.L[s,n];
sigma.FX[s,n]$(kno_inp[s,n]) = sigma.L[s,n];
eta.FX[s,n]$(kno_out[s,n]) = eta.L[s,n];
PwT.FX[s,n]$(inp[s,n]) = PwT.L[s,n];
qS.FX[s,n]$(out[s,n]) = qS.L[s,n];
tauS.FX[s,n]$(out[s,n]) = tauS.L[s,n];
tauLump.FX[s]$(s_prod[s]) = tauLump.L[s];
$onlisting

# ----------------------------------------------------------------------------------------------------$UNFIX p_static_g_endovars, p_static_g_calib_exo;
# ----------------------------------------------------------------------------------------------------
$offlisting
PwT.lo[s,n]$(int[s,n]) = -inf;
PwT.up[s,n]$(int[s,n]) = inf;
qD.lo[s,n]$((inp[s,n]) or (int[s,n])) = -inf;
qD.up[s,n]$((inp[s,n]) or (int[s,n])) = inf;
PbT.lo[s,n]$(((out[s,n] and not endo_PbT[s,n])) or (endo_PbT[s,n])) = -inf;
PbT.up[s,n]$(((out[s,n] and not endo_PbT[s,n])) or (endo_PbT[s,n])) = inf;
Peq.lo[n]$(n_out[n]) = -inf;
Peq.up[n]$(n_out[n]) = inf;
$onlisting

# ----------------------------------------------------------------------------------------------------
#  Define p_static_B model
# ----------------------------------------------------------------------------------------------------
Model p_static_B /
E_zp_out_upper_nest, E_zp_nout_upper_nest, E_q_out_upper_nest, E_q_nout_upper_nest, E_pw_p_static, E_zp_out_lower_nests, E_zp_nout_lower_nests, E_q_out_lower_nests, E_q_nout_lower_nests
/;

scalars p_static_B_modelstat, p_static_B_solvestat;
solve p_static_B using CNS;
p_static_B_modelstat = p_static_B.modelstat; p_static_B_solvestat = p_static_B.solvestat;
;
